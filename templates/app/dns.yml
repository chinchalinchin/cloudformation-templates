AWSTemplateFormatVersion: "2010-09-09"

Description: "A stack containing the resources to route traffic to the appropriate destination, via AWS DNS record sets. This stack should be stood up after the rest of the application stack, once everything else has been successfully provisioned. The template can conditionally provision the hosted zone and certificate for a domain that has been registered. If template is not told to configure this values, it will need the hosted zone ID and the certificate ID passed in through parameters"

Parameters:
  DNS:
    Type: String
    Description: "If DNS has been configured, you do not need this parameter. If you want to set up the DNS configuration for a domain, pass in `true`."
    AllowedValues:
      - true
      - false
    Default: false
  domain:
    Type: String
    Default: makpar-innovation.com
  subdomain:
    Type: String
    Default: laboratory
  environmentName:
    Type: String
    Default: Dev
  certificateId:
    Type: String
    Description: "If the DNS has been configured prior to this template, you must pass in the CertificateId for the associated domain. Otherwise, you do not need this parameter."
    Default: ${AWS::NoValue}
  hostedZoneId:
    Type: String
    Description: "If the DNS has been configured prior to this template, you must pass in the HostedZoneId for the associated domain and record set. Otherwise, you do not need this paramter."
    Default: ${AWS::NoValue}    
  frontendStack:
    Type: String
    Default: Innolab-FrontendStack-Dev
  gatewayStack:
    Type: String
    Default: Innolab-GatewayStack-Dev
  sonarStack:
    Type: String
    Default: Innolab-SonarStack

Conditions:
  DNSExists: !Equals 
    - !Ref DNS
    - true
  
  NotDNSExists: !Not
    - Condition: DNSExists

  DevInstances: !Equals
  - !Ref environmentName
  - Dev

Mappings:
  SubEnvDomainMap:
    Dev: 
      subdomainEnv:  "-dev"
    Test: 
      subdomainEnv: "-test"
    Staging: 
      subdomainEnv: "-staging"
    Prod: 
      subdomainEnv: ""

Resources:
  HostedZone:
    Description: "Hosted Zone that is provisioned if DNS configuration does not exist."
    Condition: NotDNSExists
    Type: 'AWS::Route53::HostedZone'
    Properties:
      Name: !Sub "${domain}"

  Certificate:
    Description: "Certificate that is provisioned if DNS confiuration does not exist."
    Condition: NotDNSExists
    Type: 'AWS::CertificateManager::Certificate'
    Properties:
      DomainName: !Sub "*.${domain}"
      ValidationMethod: DNS

  RestAPIDomainName:
    Type: 'AWS::ApiGateway::DomainName'
    Properties:
      CertificateArn: 
        !If [DNSExists, !Sub "arn:aws:acm:us-east-1:${AWS::AccountId}:certificate/${certificateId}", !Sub "arn:aws:acm:us-east-1:${AWS::AccountId}:certificate/${Certificate}"]
      DomainName: !Sub 
        - "api-${subdomainName}${subdomainEnv}.${domainName}"
        - subdomainEnv: 
            Fn::FindInMap:
              - SubEnvDomainMap
              - !Ref environmentName
              - subdomainEnv
          subdomainName: !Ref subdomain
          domainName: !Ref domain
      EndpointConfiguration:
        Types:
          - EDGE

  RestAPIBasePathMapping:
    Type: 'AWS::ApiGateway::BasePathMapping'
    Properties:
      DomainName: !Ref RestAPIDomainName
      RestApiId: 
        Fn::ImportValue: !Sub ${gatewayStack}-RestAPIID
      Stage: !Ref environmentName

  RestAPIRoute53RecordSetGroup:
    Type: AWS::Route53::RecordSetGroup
    Properties:
      HostedZoneId: !If [DNSExists, !Ref hostedZoneId, !Ref HostedZone]
      RecordSets:
        - Name: !Sub 
            - "api-${subdomainName}${subdomainEnv}.${domainName}"
            - subdomainEnv: 
                Fn::FindInMap:
                  - SubEnvDomainMap
                  - !Ref environmentName
                  - subdomainEnv
              subdomainName: !Ref subdomain
              domainName: !Ref domain
          Type: A
          AliasTarget:
            HostedZoneId: !GetAtt RestAPIDomainName.DistributionHostedZoneId
            DNSName: !GetAtt RestAPIDomainName.DistributionDomainName
    DependsOn:
      - RestAPIDomainName
  
  SonarRoute53RecordSetGroup:
    # NOTE: Condition & The HostedZoneId
    Condition: DevInstances
    Type: AWS::Route53::RecordSetGroup
    Properties:
      HostedZoneId: !If [DNSExists, !Ref hostedZoneId, !Ref HostedZone]
      RecordSets:
        - Name: !Sub "${subdomain}-sonar.${domain}"
          Type: A
          ResourceRecords:
            - Fn::ImportValue: !Sub ${sonarStack}-SonarPublicIP
          TTL: 900

  FrontendBucketLogs:
    Type: AWS::S3::Bucket
    DeletionPolicy: Delete
    Properties:
      AccessControl: LogDeliveryWrite
      BucketName: !Sub 
        - "${applicationName}-frontend${environment}-logs"
        - environment: 
            Fn::FindInMap:
              - SubEnvDomainMap
              - !Ref environmentName
              - subdomainEnv

  FrontendDeployBucket:
    Type: AWS::S3::Bucket
    DeletionPolicy: Delete
    Properties:
      AccessControl: PublicRead
      BucketName: !Sub 
        - "${applicationName}-frontend${environment}-deployment"
        - environment:
            Fn::FindInMap:
              - SubEnvDomainMap
              - !Ref environmentName
              - subdomainEnv
      LoggingConfiguration:
        DestinationBucketName: !Ref FrontendBucketLogs
        LogFilePrefix: 'cdn/'
      WebsiteConfiguration:
        IndexDocument: 'index.html'
        ErrorDocument: 'index.html'

  DeployBucketPolicy:
    Type: AWS::S3::BucketPolicy
    Properties:
      Bucket: !Ref FrontendDeployBucket
      PolicyDocument:
        Version: '2012-10-17'
        Statement:
          - Effect: 'Allow'
            Action: 
              - "s3:GetObject"
              - "s3:PutObject"
              - "s3:DeleteObject"
            Principal: '*'
            Resource: !Sub '${FrontendDeployBucket.Arn}/*'
    DependsOn:
      - FrontendDeployBucket

  FrontendDistribution:
    Type: "AWS::CloudFront::Distribution"
    Properties:
      DistributionConfig: 
        Aliases: 
          - !Sub
            - "${subdomainName}${subdomainEnv}.${domainName}"
            - subdomainName: !Ref subdomain
              domainName: !Ref domain
              subdomainEnv: 
                Fn::FindInMap:
                  - SubEnvDomainMap
                  - !Ref environmentName
                  - subdomainEnv
        Origins: 
        - ConnectionAttempts: 3
          ConnectionTimeout: 10
          DomainName: !GetAtt FrontendDeployBucket.DomainName
          Id: !Ref FrontendDeployBucket
          CustomOriginConfig:
              HTTPPort: 80
              HTTPSPort: 443
              OriginKeepaliveTimeout: 5
              OriginProtocolPolicy: 'https-only'
              OriginReadTimeout: 30
              OriginSSLProtocols:
                - TLSv1
                - TLSv1.1
                - TLSv1.2
        DefaultCacheBehavior: 
          AllowedMethods: 
          - "HEAD"
          - "DELETE"
          - "POST"
          - "GET"
          - "OPTIONS"
          - "PUT"
          - "PATCH"
          CachedMethods: 
          - "HEAD"
          - "GET"
          ForwardedValues:
            Cookies:
              Forward: none
            QueryString: true
          Compress: false
          SmoothStreaming: false
          TargetOriginId: !Ref FrontendDeployBucket
          ViewerProtocolPolicy: "redirect-to-https"
        CustomErrorResponses:
          ErrorCode: 404
          ResponseCode: 200
          ResponsePagePath: /index.html
        PriceClass: "PriceClass_All"
        Enabled: true
        ViewerCertificate: 
          AcmCertificateArn: !If [DNSExists, !Sub "arn:aws:acm:us-east-1:${AWS::AccountId}:certificate/${certificateId}", !Sub "arn:aws:acm:us-east-1:${AWS::AccountId}:certificate/${Certificate}"]
          MinimumProtocolVersion: "TLSv1.2_2019"
          SslSupportMethod: "sni-only"
        HttpVersion: "http2"
        DefaultRootObject: 'index.html'
        IPV6Enabled: true
        Logging:
          Bucket: !GetAtt FrontendBucketLogs.DomainName
          IncludeCookies: false
          Prefix: 'cdn/'
  
  CoverageBucket:
    Type: AWS::S3::Bucket
    Condition: DevInstances
    DeletionPolicy: Delete
    Properties:
      AccessControl: PublicRead
      BucketName: !Sub 
        - "${applicationName}-coverage${environment}"
        - environment:
            Fn::FindInMap:
              - SubEnvDomainMap
              - !Ref environmentName
              - subdomainEnv
      LoggingConfiguration:
        DestinationBucketName: !Ref FrontendBucketLogs
        LogFilePrefix: 'cov/'
      WebsiteConfiguration:
        IndexDocument: 'index.html'

  CoverageBucketPolicy:
    Type: AWS::S3::BucketPolicy
    Condition: DevInstances
    Properties:
      Bucket: !Ref CoverageBucket
      PolicyDocument:
        Version: '2012-10-17'
        Statement:
          - Effect: 'Allow'
            Action: 
              - "s3:GetObject"
              - "s3:PutObject"
              - "s3:DeleteObject"
            Principal: '*'
            Resource: !Sub '${CoverageBucket.Arn}/*'
    DependsOn:
      - CoverageBucket

  CoverageDistribution:
    Type: "AWS::CloudFront::Distribution"
    Condition: DevInstances
    Properties:
      DistributionConfig: 
        Aliases: 
          - !Sub "${subdomain}-coverage.${domain}"
        Origins: 
        - ConnectionAttempts: 3
          ConnectionTimeout: 10
          DomainName: !GetAtt CoverageBucket.DomainName
          Id: !Ref CoverageBucket
          CustomOriginConfig:
              HTTPPort: 80
              HTTPSPort: 443
              OriginKeepaliveTimeout: 5
              OriginProtocolPolicy: 'https-only'
              OriginReadTimeout: 30
              OriginSSLProtocols:
                - TLSv1
                - TLSv1.1
                - TLSv1.2
        DefaultCacheBehavior: 
          AllowedMethods: 
          - "HEAD"
          - "DELETE"
          - "POST"
          - "GET"
          - "OPTIONS"
          - "PUT"
          - "PATCH"
          CachedMethods: 
          - "HEAD"
          - "GET"
          ForwardedValues:
            Cookies:
              Forward: none
            QueryString: true
          Compress: false
          SmoothStreaming: false
          TargetOriginId: !Ref CoverageBucket
          ViewerProtocolPolicy: "redirect-to-https"
        PriceClass: "PriceClass_All"
        Enabled: true
        ViewerCertificate: 
          AcmCertificateArn: !If [DNSExists, !Sub "arn:aws:acm:us-east-1:${AWS::AccountId}:certificate/${certificateId}", !Sub "arn:aws:acm:us-east-1:${AWS::AccountId}:certificate/${Certificate}"]
          MinimumProtocolVersion: "TLSv1.2_2019"
          SslSupportMethod: "sni-only"
        HttpVersion: "http2"
        DefaultRootObject: 'index.html'
        IPV6Enabled: true
        Logging:
          Bucket: !GetAtt FrontendBucketLogs.DomainName
          IncludeCookies: false
          Prefix: 'cov/'

  FrontendRoute53RecordSetGroup:
    Type: AWS::Route53::RecordSetGroup
    Properties:
      HostedZoneId: !If [DNSExists, !Ref hostedZoneId, !Ref HostedZone]
      RecordSets:
        - Name: !Sub
            - "${subdomainName}${subdomainEnv}.${domainName}"
            - subdomainName: !Ref subdomain
              domainName: !Ref domain
              subdomainEnv: 
                Fn::FindInMap:
                  - SubEnvDomainMap
                  - !Ref environmentName
                  - subdomainEnv
          Type: A
          AliasTarget:
            DNSName: !GetAtt FrontendDistribution.DomainName
            EvaluateTargetHealth: false
            # Specify Z2FDTNDATAQYW2. This is always the hosted zone ID when you create an
            # alias record that routes traffic to a CloudFront distribution.
            HostedZoneId: Z2FDTNDATAQYW2
    DependsOn:
      - FrontendDistribution

  CoverageRoute53RecordSetGroup:
    Type: AWS::Route53::RecordSetGroup
    Condition: DevInstances
    Properties:
      HostedZoneId: !If [DNSExists, !Ref hostedZoneId, !Ref HostedZone]
      RecordSets:
        - Name: !Sub
            - "${subdomainName}-coverage${subdomainEnv}.${domainName}"
            - subdomainName: !Ref subdomain
              domainName: !Ref domain
              subdomainEnv: 
                Fn::FindInMap:
                  - SubEnvDomainMap
                  - !Ref environmentName
                  - subdomainEnv
          Type: A
          AliasTarget:
            DNSName: !GetAtt CoverageDistribution.DomainName
            EvaluateTargetHealth: false
            # Specify Z2FDTNDATAQYW2. This is always the hosted zone ID when you create an
            # alias record that routes traffic to a CloudFront distribution.
            HostedZoneId: Z2FDTNDATAQYW2
    DependsOn:
      - CoverageDistribution

Outputs: 
  RestAPIDomain:
    Condition: DNSExists
    Value: !Ref RestAPIDomainName
    Export:
      Name: !Sub ${AWS::StackName}-RestAPIDomainName
  CertificateId:
    Condition: NotDNSExists
    Value: !If [NotDNSExists, !Ref Certificate, !Ref certificateId]
    Export:
      Name: !Sub ${AWS::StackName}-CertificateID
  HostedZoneId:
    Condition: NotDNSExists
    Value: !If [NotDNSExists, !Ref HostedZone, !Ref hostedZoneId]
    Export:
      Name: !Sub ${AWS::StackName}-HostedZoneID
  FrontendDistributionID:
    Value: !Ref FrontendDistribution
    Description: Resource ID for CloudFront Distribution
    Export:
      Name: !Sub ${AWS::StackName}-FrontendDistributionID
  FrontendDomain:
    Value: !GetAtt FrontendDistribution.DomainName
    Description: Domain name of CloudFront Distribution
    Export:
      Name: !Sub ${AWS::StackName}-FrontendDistributionDomain
  CoverageDistributionID:
    Value: !Ref CoverageDistribution
    Description: Resource ID for CloudFront Distribution
    Export:
      Name: !Sub ${AWS::StackName}-CoverageDistributionID
  CoverageDomain:
    Value: !GetAtt CoverageDistribution.DomainName
    Description: Domain name of CloudFront Distribution
    Export:
      Name: !Sub ${AWS::StackName}-CoverageDistributionDomain